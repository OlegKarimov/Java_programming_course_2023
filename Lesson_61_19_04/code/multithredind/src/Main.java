public class Main {
    public static void main(String[] args) {

//         //  Многопоточность
    /*
    Многопоточность

Большинство языков программирования поддерживают такую важную функциональность как многопоточность, и Java в этом плане не исключение. При помощи многопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. Если у нас, допустим, графическое приложение, которое посылает запрос к какому-нибудь серверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. А благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток. Поэтому большинство реальных приложений, которые многим из нас приходится использовать, практически не мыслимы без многопоточности.

Класс Thread
В Java функциональность отдельного потока заключается в классе Thread. И чтобы создать новый поток, нам надо создать объект этого класса. Но все потоки не создаются сами по себе. Когда запускается программа, начинает работать главный поток этой программы. От этого главного потока порождаются все остальные дочерние потоки.
По умолчанию именем главного потока будет main.

Для управления потоком класс Thread предоставляет еще ряд методов. Наиболее используемые из них:

getName(): возвращает имя потока

setName(String name): устанавливает имя потока

getPriority(): возвращает приоритет потока

setPriority(int proirity): устанавливает приоритет потока. Приоритет является одним из ключевых факторов для выбора системой потока из кучи потоков для выполнения. В этот метод в качестве параметра передается числовое значение приоритета - от 1 до 10. По умолчанию главному потоку выставляется средний приоритет - 5.

isAlive(): возвращает true, если поток активен

isInterrupted(): возвращает true, если поток был прерван

join(): ожидает завершение потока

run(): определяет точку входа в поток

sleep(): приостанавливает поток на заданное количество миллисекунд

start(): запускает поток, вызывая его метод run()

Foote

//    Многозадачность бывает двух типов:
//    process-based , т.е. когда есть несколько одновременно работающих
//    процессов (программ)
//    thread-based  - когда одна программа выполняется в нескольких потоках
//    Поток может находиться в нескольких состояниях :
//    1. running -  рабочее состояние, работает
//    2. ready to run -  готов приступить к работе как только получит доступ к процессору(процессорное время)
//    3. suspended - работающий поток может быть временно приостановлен
//    4. blocked -  когда поток не может получить доступ к требуемому ресурсу
//    5. termintated - выполнение прекращается  и не может быть возобновлено
//    В многопоточности очень важным является вопрос синхронизации. Синхронизация позволяет
//    координировать работу потоков определенным продуманным образом.

     // Создание потока.

    /*
    Поток можно создать двумя способами - используя класс Thread  или интерфейс
    Runnable
    I. Interface Runnable
    Runnable  имеет единственный метод public void run()
    Написанный внутри этого метода  код можно запустить в новом потоке.
    Метод run  является полноценным методом ( в нем можно вызывать другие методы,
    использовать другие классы, создавать переменные) Его отличие заключается
    в том, что он представляет собой точку входа для нового параллельного потока
    в программе. Этот поток закончится  с окончанием исполнения метода run()
    После создания  класса реализующего интерфейс Runnable  создается обьект класса Thread использующий
    обьект Runnable -    Thread( Runnable ob)
    После создания поток не запустится автоматически.  Для этого нужно вызвать метод start() класса Thread
    Фактически, этот метод осуществляет вызов метода run()
    void start()
     */

        System.out.println("Main thread starts");

        //создание обьекта, реализующего интерфейс Runnable
        //  MyThread myThread = new MyThread("Thread1");

        //создание потока на этом обьекте
        //   Thread newThread = new Thread(myThread);
        // Thread newThread1 = new Thread(myThread,"Thread2");

        //запуск потока
        //   newThread.start();

        //создание через класс
        MyThread1 myThread1 = new MyThread1("Thread 1");
        myThread1.start();
        MyThread1 myThread1a = new MyThread1("Thread 1a");
        MyThread1 myThread1b = new MyThread1("Thread 1b");
        myThread1a.start();
        myThread1b.start();


        for (int i = 0; i < 100; i++) {
            System.out.print("#");
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                System.out.println("main thread interrupted");
            }
        }
        System.out.println("Main thread ends");
    }
    /*
    Main thread starts
#Thread1starts
###in thread Thread1 counter is 0
####in thread Thread1 counter is 1
####in thread Thread1 counter is 2
####in thread Thread1 counter is 3
###in thread Thread1 counter is 4
####in thread Thread1 counter is 5
####in thread Thread1 counter is 6
####in thread Thread1 counter is 7
###in thread Thread1 counter is 8
####in thread Thread1 counter is 9
Thread1terminates
##############################################################Main thread ends
II. Создание потока через класс Thread
-происходит через создание класса, расширяющего Thread  и переопределения метода run()
     */
}