package Lektions;

import java.util.HashSet;
import java.util.Scanner;

public class Lektion_20_02 {
    public static void main(String[] args) {
/*
//Задача 1: посчитать количество разных слов в тексте (частоту повторений пока посчитать не можем).
// Это "класическая" задача на HashMap и "лексический разбор".

        System.out.println("Латинский алфавит");
        // Заполним множество символами латинского алфавита в цикле for
        // код символа "A" - 65, код символа "B" - 66, и т.д. до код "Z" = 90.

        HashSet<String> latAlphabet = new HashSet<String>(); //инициализация HashMap
        System.out.println();
        // заполняем HashSet в цикле
        for (int i = 0; i < 26; i++) {
            latAlphabet.add(String.valueOf((char) (i + 65))); // берем букву, соответствующую символу
        }
        System.out.println(latAlphabet); // печать полученного сета
        // Добавим опять, еще раз букву K
        latAlphabet.add("K");
        System.out.println();
        System.out.println(latAlphabet); // печать сета

// --------------------------------------------------------------------------------------------------------
// Задача 2: имеется список чисел, необходимо собрать его в множество (убрать повторы),
// удалить все чётные элементы множества.
        System.out.println("Добрый день!");
        //**Задача:** Написать приложение, которое позволит понять,
        // из каких мест на данную почту приходят письма.
        // Что на входе: Письмо с почтовым индексом (post_code).
        // Что на выходе: список уникальных индексов, откуда приходили письма.
        // Интерфейс: пользователь (операционист) вводит почтовый индекс с письма,
        // ввод продолжается до тех пор, пока пользователь готов продолжать работу.
        // Ключевой алгоритм: заносим индекс в HashSet, эта структура сама заботиться, об уникальности,
        // содержащихся в ней элементов, повторный ввод почтового индекса не "испортит" множество уникальных индексов
        // ии его не надо "обрабатывать.
        // Для ввода организуем бесконечный цикл while (true)

        System.out.println("Ввод индексов с приходящих на почту писем"); // Приглашение пользователю
        Scanner userInput = new Scanner(System.in); // считываем ввод пользователя

        String p_code = ""; // переменная для почтового индекса
        char userChoice; // переменная для выбора пользователя
        int hash = 0;

        HashSet<String> postCode = new HashSet<String>(); //инициализация HashMap

        do {
            System.out.println("Введите индекс письма: ");
            p_code = userInput.next(); // Cчитываем от пользователя индекс
            postCode.add(p_code); // Добавили индекс в HashMap
            // System.out.println(p_code.hashCode());
            // Интерфейс продолжения работы
            System.out.println("Для для остановки нажмите S, чтобы продолжить - любую другую букву.");
            userChoice = userInput.next().toLowerCase().charAt(0); // имя_сканера.next().toLowerCase().charAt(0);
            if (userChoice == 's') {
                break;
            }
        } while (true);

        System.out.println("Введенные за смену почтовые индексы: ");
        System.out.println(postCode);
        System.out.println();
        // печать циклом for each
        for (String st : postCode) {
            System.out.println(st);
        }

        System.out.println();
        do {
            System.out.println("Проверка, есть ли уже такой почтовый индекс?");
            System.out.println("Введите индекс письма: ");
            p_code = userInput.next(); // Cчитываем от пользователя индекс
            if (postCode.contains(p_code)) {
                System.out.println("Да, такой индекс уже есть.");
            } else {
                System.out.println("Нет, такого индекса еще нет.");
            }
            ;
            // Интерфейс продолжения проверки
            System.out.println("Для для остановки проверки нажмите s, чтобы продолжить - любую другую букву.");
            userChoice = userInput.next().toLowerCase().charAt(0); // имя_сканера.next().toLowerCase().charAt(0);
            if (userChoice == 's') {
                break;
            }
        } while (true);
*/

        //посчитать количество разных слов в тексте (частоту повторений пока посчитать не можем).
        // Это "класическая" задача на HashMap и "лексический разбор".
        System.out.println("Задача на кол. уникальных слов");
        String sentence = ("В 1800-х годах, в те времена, когда не было еще ни железных, ни шоссейных дорог, ни газового, ни стеаринового света, ни пружинных низких диванов, ни мебели без лаку, ни разочарованных юношей со стеклышками, ни либеральных философов-женщин, ни милых дам-камелий, которых так много развелось в наше время, – в те наивные времена, когда из Москвы, выезжая в Петербург в повозке или карете, брали с собой целую кухню домашнего приготовления, ехали восемь суток по мягкой, пыльной или грязной дороге и верили в пожарские котлеты, в валдайские колокольчики и бублики, – когда в длинные осенние вечера нагорали сальные свечи, освещая семейные кружки из двадцати и тридцати человек, на балах в канделябры вставлялись восковые и спермацетовые свечи, когда мебель ставили симметрично, когда наши отцы были еще молоды не одним отсутствием морщин и седых волос, а стрелялись за женщин и из другого угла комнаты бросались поднимать нечаянно и не нечаянно уроненные платочки, наши матери носили коротенькие талии и огромные рукава и решали семейные дела выниманием билетиков, когда прелестные дамы-камелии прятались от дневного света, – в наивные времена масонских лож, мартинистов, тугендбунда, во времена Милорадовичей, Давыдовых, Пушкиных, – в губернском городе К. был съезд помещиков, и кончались дворянские выборы.");
        System.out.println(sentence);
        System.out.println(sentence.length());

        String[] s = sentence.split(" ");
        System.out.println(s.length);

        HashSet<String> wordsOfSen = new HashSet<String>();
        for (int i = 0; i < s.length; i++) {
            wordsOfSen.add(s[i]);
        }

        int t = wordsOfSen.size();
        System.out.println("Кол. слов в предложении : " + t);
        
    }
}
